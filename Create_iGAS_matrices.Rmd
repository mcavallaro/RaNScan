---
title: "Create observation and baseline iGAS matrices"
author: "Massimo Cavallaro"
date: "26 June 2020"
output: word_document
---


```{r}
rm(list=ls())

tryCatch(
  load("iGAS_coords.Rdata"),
  error = function(e){
    # this loads `iGAS.Rdata` as input and and save `iGAS_coords.Rdata` which is filtered, preprocess, and with spatial coordinates.
    source("init.R")
  }
)
```

To plot:
```
library(sf)
map = read_sf("England_AL4-AL4.shp")
idx = sample(1:dim(A)[1], 1000)
plot(map$geometry )

#plot(latitude ~ longitude, data=A[idx,], ylim=c(50,60), asp=1 )
points(dat$longitude, dat$latitude, col = 'red')
# print(unique(dat$PHE_CENTRE_NAME))
```



```{r}
postcodes = unique(dat$`Patient Postcode`)
emmtypes = unique(dat$emmtypes2)

n.postcodes= length(postcodes)
n.emmtypes = length(emmtypes)
n.weeks = max(dat$SAMPLE_DT_numeric[!is.na(dat$SAMPLE_DT_numeric)]) - min(dat$SAMPLE_DT_numeric[!is.na(dat$SAMPLE_DT_numeric)]) + 1
cat(n.postcodes, n.emmtypes,n.weeks)
```

# Create `observation.matrix`

```{r}
observation.matrix = array(data=0,
                dim = c(n.postcodes, n.emmtypes, n.weeks + 2),
                dimnames=list(postcodes, emmtypes, c('NA', as.character(0:n.weeks)) ))
# the dimensions correspond to postcode, emmtype, time  

for (i in 1:nrow(dat)){
  emmtype = dat[i,'emmtypes2']
  postcode = dat[i,'Patient Postcode']
  week = dat[i, 'SAMPLE_DT_numeric']
  if (is.na(week)){
    week = 'NA'
  }
  observation.matrix[postcode, emmtype, as.character(week)] = observation.matrix[postcode, emmtype, as.character(week)] + 1
}


save("observation.matrix", file="iGAS_observation_matrix.Rdata")

```


```{r}
sum(observation.matrix)
observation.matrix[1:4, 1:4, 1:4]
```

# Create a dataframe to map postcodes to coordinates

```{r}
tryCatch(
  load("postcode2coord.Rdata"),
  error=function(e){
    postcode2coord = data.frame(post.codes = rownames(observation.matrix[,,1]))
    # Insert coordinates
    UKpostcodes = read.csv("ukpostcodes.csv", stringsAsFactors = F)
    source("utils.R")
    postcode2coord[,c("latitude", "longitude")] = t(apply(postcode2coord, 1, postcode.to.location, UKpostcodes))
    save('postcode2coord', file="postcode2coord.Rdata")
  }
)
```

#  Find baselines factorising emmtypes, postocode, and time under 4 strategies:

## 1

```{r}
baseline.matrix.1 = array(data=0,
                dim = c(n.postcodes, n.emmtypes, n.weeks + 2),
                dimnames=list(postcodes, emmtypes, c('NA', as.character(0:n.weeks)))
                
)

time.factor = apply(observation.matrix, c(1,2), sum)
emmtype.factor = apply(observation.matrix, c(1,3), sum)
location.factor = apply(observation.matrix, c(2,3), sum)

for(i in 1:dim(observation.matrix)[1]){
  for(j in 1:dim(observation.matrix)[2]){
    for(k in 1:dim(observation.matrix)[3]){
      baseline.matrix.1[i,j,k] <- time.factor[i,j] * emmtype.factor[i,k] * location.factor[j,k]
    }
  }
}

baseline.matrix.1 = baseline.matrix.1 * sum(observation.matrix) / sum(baseline.matrix.1)
save("baseline.matrix.1", file="iGAS_baseline_matrix_1.Rdata")

```

## 2

```{r}
baseline.matrix.2 = array(data=0,
                dim = c(n.postcodes, n.emmtypes, n.weeks + 2),
                dimnames=list(postcodes, emmtypes, c('NA', as.character(0:n.weeks)))
                
)

time.factor = apply(observation.matrix, 3, sum)
emmtype.factor = apply(observation.matrix, 2, sum)
location.factor = apply(observation.matrix, 1, sum)


for(i in 1:dim(observation.matrix)[1]){
  for(j in 1:dim(observation.matrix)[2]){
    for(k in 1:dim(observation.matrix)[3]){
      baseline.matrix.2[i,j,k] <- time.factor[k] * emmtype.factor[j] * location.factor[i]
    }
  }
}
# cat(sprintf("%d\r", i))
baseline.matrix.2 = baseline.matrix.2 * sum(observation.matrix) / sum(baseline.matrix.2)
save("baseline.matrix.2", file="iGAS_baseline_matrix_2.Rdata")

```

```{r}
time.factor = apply(observation.matrix, 3, sum)
emmtype.factor = apply(observation.matrix, 2, sum)
location.factor = apply(observation.matrix, 1, sum)
sample.emmtypes = emmtypes[order(emmtype.factor)] %>% tail
sample.postcodes = postcodes[order(location.factor)] %>% tail
```


#  12.0  66.0 108.1  89.0    NA   1.0 
#   159   203   246   249   266   454
# NG5 3AG LE2 7AJ B18 4AS LE2 0JN B97 6QS      NA 
#      13      23      30      31      67     705 


```
par(mfrow = c(2,3))
for(emmtype in sample.emmtypes){
  for(postcode in sample.postcodes){
    maximum = max(observation.matrix[postcode, emmtype, ])
    # if (maximum == 0){
    #   maximum = 1
    # }
    maximum = 2
    data = observation.matrix[postcode, emmtype, ]
    color = ifelse(data > 0, 'black', 'white')
    plot(data, xlab = 'week', ylab='counts', ylim = c(0,maximum), main = paste(emmtype, postcode, sep=', '), col=color)
    lines(baseline.matrix.2[postcode,emmtype,], col = 'red')
  }
}
#dev.off()

```


## 3 Conditional Maximum Likelihood

```{r}
source("time_utils.R")
time.factor = apply(observation.matrix, 3, sum)

tmp = expand.histogram(time.factor[-c(1,  270:330)])
Parameters =  cmle(tmp, 50)
x <- as.numeric(dimnames(observation.matrix)[[3]][-1])
prediction.cmle = predict.cmle(x, Parameters)
```



```{r}
baseline.matrix.3 = array(data=0,
                dim = c(n.postcodes, n.emmtypes, n.weeks + 2),
                dimnames=list(postcodes, emmtypes, c('NA', as.character(0:n.weeks)))
                
)

time.factor = c(time.factor[1], prediction.cmle)
emmtype.factor = apply(observation.matrix, 2, mean)
location.factor = apply(observation.matrix, 1, mean)


for(i in 1:dim(observation.matrix)[1]){
  for(j in 1:dim(observation.matrix)[2]){
    for(k in 1:dim(observation.matrix)[3]){
      baseline.matrix.3[i,j,k] <- time.factor[k] * emmtype.factor[j] * location.factor[i]
    }
  }
}
# cat(sprintf("%d\r", i))
baseline.matrix.3 = baseline.matrix.3 * sum(observation.matrix) / sum(baseline.matrix.3)
save("baseline.matrix.3", file="iGAS_baseline_matrix_3.Rdata")
```


## 4 LOESS


```{r}
source("time_utils.R")
time.factor = apply(observation.matrix, 3, sum)
fit = Loess(time.factor[-1])

x <- as.numeric(dimnames(observation.matrix)[[3]][-1])
prediction.loess = predict.Loess(x, fit)
```



```{r}
baseline.matrix.4 = array(data=0,
                dim = c(n.postcodes, n.emmtypes, n.weeks + 2),
                dimnames=list(postcodes, emmtypes, c('NA', as.character(0:n.weeks)))
                
)

time.factor = c(time.factor[1], prediction.loess)
emmtype.factor = apply(observation.matrix, 2, mean)
location.factor = apply(observation.matrix, 1, mean)


for(i in 1:dim(observation.matrix)[1]){
  for(j in 1:dim(observation.matrix)[2]){
    for(k in 1:dim(observation.matrix)[3]){
      baseline.matrix.4[i,j,k] <- time.factor[k] * emmtype.factor[j] * location.factor[i]
    }
  }
}
# cat(sprintf("%d\r", i))
baseline.matrix.4 = baseline.matrix.4 * sum(observation.matrix) / sum(baseline.matrix.4)
save("baseline.matrix.4", file="iGAS_baseline_matrix_4.Rdata")
```



# compare the last three strategies


```{r}
# png('time_factor.png', width = 3.25,height = 3.25, units = 'in', res=500, pointsize = 4)
par(mar=c(2,2,4,2))

plot(apply(observation.matrix,3, sum)[-1], xlab = 'week', ylab='cases', xaxt='n', lwd=0.4, cex=1.5, main='Temporal baselines')
axis(1, at=seq(0,300,25), week2Date(seq(0,300,25)))
x <- as.numeric(dimnames(observation.matrix)[[3]][-1])

ci = predict.Loess.ci(x, fit)
col = paste0(col2hex('orange'), '55')
polygon(c(x, x[length(x):1]), c(ci$upper, ci$lower[length(ci$lower):1]), border=NA, col=col)

ci = predict.cmle.ci(x, Parameters)
col = paste0(col2hex('red'), '33')
polygon(c(x, x[length(x):1]), c(ci$upper, ci$lower[length(ci$lower):1]), border=NA, col=col)


lines(x, predict.cmle(x, Parameters), col='red', lwd=2)
lines(x, prediction.loess, col='orange', lwd=1.5)


legend("topleft", pch=c(1,NA,NA), lty = c(NA, 1,1), lwd=c(0.4, 1.5, 2), pt.cex=c(1.5,1,1), col=c('black', 'red', 'orange'), c("Temporal baseline 1 (sum)", "Temporal baseline 2 (cMLE)","Temporal baseline 3 (LOESS)"))
# dev.off()
```



```{r}
png('scaled_time_factor.png') #, width = 3.25,height = 3.25, units = 'in', res=500, pointsize = 4)
par(mar=c(4,4,4,4))
plot(c(x,x), c(predict.cmle(x, Parameters)*a, predict.cmle(x, Parameters)*b), col='white', lwd=2, type='l', ylab = 'cMLE time factor', xaxt='n', xlab='')
a = 368 / (368 + 185 + 700)
b = 185 / (368 + 185 + 700)
lines(x, predict.cmle(x, Parameters)*a, col='green', lwd=2)
lines(x, predict.cmle(x, Parameters)*b, col='blue', lwd=2)
axis(1, at=seq(0,300,25), week2Date(seq(0,300,25)))
legend("topleft", pch=c(NA,NA), lty = c(1,1), lwd=c(2,2), col=c('green', 'blue'), c("1.0", "98.0"))
dev.off()

```

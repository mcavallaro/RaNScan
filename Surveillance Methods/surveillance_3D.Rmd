---
title: "Surveillance 3D"
author: "Massimo Cavallaro"
date: "22 October 2019"
output:
  pdf_document: default
  word_document: default
---


```{r message=FALSE, warning=FALSE, include=FALSE}
library("spatstat")
library("truncnorm")
```

# Baseline model definition

The basic assumption is that there are is a known baseline of (endemic) events;
as long as the recorded events are described by this baseline, no warning should be raised.
Events that are unlikely to occurr according to the baseline predictions are tagged as
potential outbreaks.

As a demonstration, we arbitarily considered a square of unit side and assumed
that the baseline $\lambda$ has a trend described by a bell (whose center
corresponds, e.g., to a region highly populated) with  trend

$$
\lambda(x,y,t) = (A/2 (\sin(t) + 1) +B)\mathrm{e}^{-B( (x-0.5)^2+(y-0.5)^2) },
$$

where $x$ and $y$ are spatial coordinates, while $t$ is an integer time index
(it seems data will be in unit of weeks, less likely days).

```{r}
# include=FALSE}
temporal.trend.function<-function(t,A=7, B=0.5){
  return (A/2*(sin(t) + 1) + B)
}

spatial.trend.function<-function(x,y, C=80, B=0.5, x0=0.5, y0=0.5){
  return(B + 20*exp(-C * ( (x-x0)^2 + (y - y0)^2)))
}

baseline=lapply(1:10, function(t){
  rpoispp(function(x,y){ temporal.trend.function(t) * spatial.trend.function(x,y) })})


win = owin(poly = data.frame(x=rev(c(0.1,0.2,0.3,0.4,0.44,0.31,0.22)),y=rev(c(0.8,0.91,0.8,0.6,0.55,0.45,0.55))) )

epidemics=lapply(c(0,0,0,0,1,1,1,1,0,0), function(t){
  rpoispp(t * 50, win=win)})

par(mfrow=c(3,3), mar=c(0.5,0.5,0.5,0.5))
for (i in 1:9){
  plot(baseline[[i]], cols='#473B54', pch=16, main=paste('week ', as.character(i)))
  if (i %in% 5:8){
    plot(win, add=T, border='red')
  }
  plot.ppp(epidemics[[i]], cols='red', pch=16, add=T)
}

```



# plot(temporal.trend(1:10))
#``{r echo=FALSE, warning=FALSE}
# # png('surveillance_3D_files/baseline.png', width = 3.25 * 5, height = 3.25, units = 'in', res=600, pointsize = 15)
# # pdf('surveillance_3D_files/baseline_3weeks.pdf')
# x = seq(0,1,0.01)
# y = seq(0,1,0.01)
# z1 = outer(x, y, function(x,y){temporal.trend(1) * spatial.trend.function(x,y)})
# z2 = outer(x, y, function(x,y){temporal.trend(2) * spatial.trend.function(x,y)})
# z3 = outer(x, y, function(x,y){temporal.trend(3) * spatial.trend.function(x,y)})
# z4 = outer(x, y, function(x,y){temporal.trend(4) * spatial.trend.function(x,y)})
# z5 = outer(x, y, function(x,y){temporal.trend(5) * spatial.trend.function(x,y)})
# z6 = outer(x, y, function(x,y){temporal.trend(6) * spatial.trend.function(x,y)})
# z7 = outer(x, y, function(x,y){temporal.trend(7) * spatial.trend.function(x,y)})
# zlim = c(0,15)
# border=NA
# phi=20
# r=2
# axes=T
# par(mfrow=c(1,6), mar=c(1,1,1,1)) 
# persp(x,y,z1, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 1")
# persp(x,y,z2, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 2")
# persp(x,y,z3, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 3")
# persp(x,y,z4, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 4")
# persp(x,y,z5, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 5")
# persp(x,y,z6, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 6")
# # dev.off()
#`{r echo=FALSE, message=FALSE, warning=FALSE}
# pdf('surveillance_3D_files/data_9_weeks.pdf')
# (c(0,0,1,1,1,1, 0,0,0,0)


```{r include=FALSE}
observations = list()
for (i in 1:10){
  b = baseline[[i]]
  s = epidemics[[i]]
  observations[[i]] = data.frame(x=c(b$x, s$x), 
                                 y=c(b$y, s$y),
                                # color=c(rep('#473B54', length(b$x)), rep('red', length(s$x))))
                                 warning=c(rep(F, length(b$x)), rep(T, length(s$x))),
  week=i)
}
observations = do.call(rbind,  observations)
```

Here is just a nicer illustration of the events in the first few weeks, I will play more with this visualisation:

```
#{r echo=FALSE, message=FALSE, warning=FALSE}
library("plot3D")

plot.cylinder<-function(x,y,rho, week_i, week_f, color){
  t<-seq(0, 2*pi, length=100)
  coords<-rbind(x+rho/2*sin(t)*2, y+rho/2*cos(t)*2)
  weeks = seq(week_i, week_f)
  for (w in weeks){
    lines3D(rep(w, 100), coords[1,], coords[2,], add=TRUE, col=color)
  }
}

# engineer the list of data.frames to be used with plot3D
for (i in 1:length(temporal.trend)){
  observations[[i]]$week = i
}

all_to_plot = do.call(rbind, list(observations[[1]], observations[[2]], observations[[3]], observations[[4]], observations[[5]], observations[[6]]))
all_to_plot$color = as.character(all_to_plot$color)

total = sapply(list(observations[[1]], observations[[2]], observations[[3]], observations[[4]], observations[[5]], observations[[6]]), dim)[1,]

for (i in seq(1,6)){
  pdf(paste('3dscatterplot', i ,'.pdf', sep='_'))
  to_plot = all_to_plot[all_to_plot$week <= i, ]
  scatter3D(to_plot$week, to_plot$x, to_plot$y, zlim=c(-0.1,1.1), ylim=c(-0.1,1.1), xlim=c(0.8,6.2),
            xlab='weeks', ylab='x', zlab='y',
            # colvar=as.numeric(as.factor(to_plot$color)),
            col='#473B54',  # unique(to_plot$color),
            colkey = FALSE, pch = 16,
            phi = 25, theta = 25, alpha.col=0.1,  expand=0.5 )
  #
  text3D(x = 1:6, y = rep(0, 6), z=rep(0, 6),
         labels = c('1', '2', '3', '4', '5', '6'),
         add = TRUE, adj = 0)
  
  w = 1:length(total)
  Z = rep(1.2,length(total))
  points3D(w, Z,total/sum(total)  * 3 , add=TRUE, col='#7570B5', pch=16,  cex=2)
  lines3D(w, Z,total/sum(total)  * 3 , add=TRUE, col='#7570B5',   lty=1, lwd=4)

  if ( i == 1){
    plot.cylinder(0.5, 0.5+i/10, 0.22, 1, 1, '#473B54')
    plot.cylinder(0.7+i/10, 0.4, 0.17, 1, 1, '#473B54')
  }else if(i < 4){
    plot.cylinder(0.5, 0.5+i/10, 0.11, i-1, i, '#473B54')
    plot.cylinder(0.4+i/10, 0.3, 0.19, i-1, i, '#473B54')
  }else{
    plot.cylinder(0.45+i/100, 0.45, 0.21, i-1, i, 'red')
    plot.cylinder(0.51, 0.49+i/100, 0.15, i-1, i, '#473B54')
  }

  dev.off()
}
# 
# slice3D( 
#        # ylim = c(0, 1), bty = "g", facets = TRUE, 
#        # border = "red", col ="#7570B3", alpha=0.5,
#        # lwd = 2, phi = 20
#        )
# dev.off()
```

# Algorithm

We dectect outbreaks by drawing random spatio-temporal portions/volumes (or maybe these should be called intervals?),
counting the number of events in each interval, and estimating the expected distribution
based on the null (baseline) model.
If the number of observed events `n_obs` in a volume falls in the upper 95% quantile,
then the interval is tagged as a canditate outbreak.
For convenience, we choose cylindrical volumes which are easy to generated as the
(ordered) tuple `(x,y,t,rho,dt)` (three spatio-tempolar coordinates of the center, plus radius of base area and half cylinder height).
```{r include=FALSE}
random_portions<-function(n,  n_weeks, border=0.1, rs=0.5, a=0, rt=2){
  # n is the number of samples
  # n_weeks
  # border is the dinstance from the boundary
  # rs is a reference size (must between zero and 1)
  # rf is a reference time scale (to be learned) 
  # generate centers:
  x = runif(n, border, 1 - border)
  y = runif(n, border, 1 - border)
  t = sample(1:n_weeks, n, replace=TRUE)
  # generate radia
  d_max =  apply(data.frame(x=x, y=y, xs=1-x, ys=1-y), 1, min) # this is min vertical distance from the border.
  rho = rtruncnorm(n, mean=rs, a=a, b=d_max)
  dt = sapply(t, function(x){ min(n_weeks-x, x-1, sample(1:rt, 1))})
  return (data.frame(x=x, y=y, t=t, rho=rho, dt=dt))
}
```

The number of events  $N$ in a random cilinder given the baseline rate
$\lambda(x,y,t)$ is a Poisson random variable
$$
N \sim \mathrm{Poi}\left(\sum_t\int_A \mathrm{d}x\mathrm{d}y \, \lambda(x,y,t) \right),
$$
where $t$ is the week index, $A$ is the surface of the base circle,  etc.
While there is no analitical expression for the
distribution of $N$ for any $A$ and $\lambda$, it is easy to simulate $N$, find a confidence interval
(5% and 95% quantiles), and assess whther the observed number of events falls into
this interval. Those intervals such that the observed count falls outside are tagged as *candidate* outbreak events.


```{r}
portions = random_portions(1000, length(temporal.trend))
head(portions)
```

Plot some of these random cylinders:
```{r echo=FALSE, message=FALSE, warning=FALSE}
pdf('surveillance_3D_files/cylinders_9_weeks.pdf')
portions.to.plot = head(portions,20)
l_weeks = apply(portions.to.plot, 1, function(x){(seq(x[3]-x[5], x[3]+x[5]))})
week_data = do.call(c, l_weeks)
portions.to.plot$ll_weeks = sapply(l_weeks, length)
#
portions.to.plot = portions.to.plot[as.numeric(rep(row.names(portions.to.plot),portions.to.plot$ll_weeks)),]
portions.to.plot$week_data = week_data

par(mfrow=c(3, 3), mar=c(0.4, 0.4, 0.4, 0.4))
for (i in 1:(length(temporal.trend) - 1)){
  plot(baseline[[i]], main=paste('week ', as.character(i)), cols='#473B54', pch=16)
  plot.ppp(epidemics[[i]], cols='red', add=T, pch=16)
  tmp_portion = portions.to.plot[portions.to.plot$week_data == i,]
  n_d = dim(tmp_portion)[1]
  if (n_d > 0){
    for (j in 1:n_d[1]){
      plot.owin(disc(tmp_portion[j,4], c(tmp_portion[j,1],tmp_portion[j,2])), add=TRUE)
    }
  }
}
dev.off()
```

Recap: we compute for each cylinder:
  
  * the number  `n_obs` of observed events within,
  * 5% and 95% quantiles (`lower` and `upper`),
  * the probability `p.val` of having `n_obs` (or more) events under the baseline model,
  * the volume of the cylinder.


```{r include=FALSE, cache=TRUE}
is_in_circle<-function(obs, x, y, rho){
  d = sqrt((as.numeric(obs[1])-x)^2 + (as.numeric(obs[2])-y)^2 )
  ifelse(d<rho, 1, 0)
}

compute<-function(portion, baseline_function=baseline_function, observations=observations){
  # portion is a spatio-temporal portion
  # baseline_function is defined above
  weeks = seq(portion[3]-portion[5], portion[3]+portion[5])
  count = 0
  for (week in weeks){
    count = count + sum(apply(observations[[week]], 1, is_in_circle, portion[1], portion[2], portion[4]))
  }
  # simulate from baseline_function for each week
  simcount = sapply(weeks, function(d){replicate(100,
    rpoispp(function(x, y){baseline_function(x, y, d )},
            win=disc(portion[4], c(portion[1], portion[2])))$n)})

  # sum over the weeks:
  simcount = rowSums(simcount)
  quantiles = quantile(simcount, probs = c(0.05,0.95))
  prob = 1-ecdf(simcount)(count)
  return (c(count, quantiles, prob))
}
portions[,c('n_obs', 'lower', 'upper', 'p.val')] = t(apply(portions, 1, compute, baseline_function, observations))
```

```{r}
head(portions)
```

Let's tag each cylinder with a `warning` flag:
```{r}
portions$warning = apply(portions, 1, function(x){ifelse(((x[6] < x[7])|(x[6] > x[8])), TRUE, FALSE)})
head(portions)
```
The candidate cyliders will be used to estimate
where the centre of the anomaly is by using a weigthed average.
These cylinders can be either false or true positive,
however, loosely speaking, false positive cylinders are evenly distributed and in average don't strongly influence the estimated outbreak center. 
It is worth noting that, for the training set, it is possible to say if each cylinder actually contains red points.
```{r include=FALSE}
Epidemics = list()
for (i in 1:length(temporal.trend)){
  if (length(epidemics[[i]]$x) > 0 ){
    Epidemics[[i]] = data.frame(x=epidemics[[i]]$x,  y=epidemics[[i]]$y, week=i);
  }else{
    Epidemics[[i]] = data.frame(x=NA, week=i, y=NA);
  }
}
contains<-function(portion, Epidemics){
  weeks = seq(portion[3]-portion[5], portion[3]+portion[5])
  count = 0
  for (week in weeks){
      count = count + sum(apply(Epidemics[[week]], 1, is_in_circle, portion[1], portion[2], portion[4]), na.rm=TRUE)
  }
  return (count>0)
}
portions$true_warning = apply(portions, 1, contains, Epidemics)
```

#  Estimate of outbreak centroid

We best estimate the outbreak center by averaging over the candidate outbreak
events centers. Obviously, we need an weighed average, as the circles have
different radia and convey different amount of information.

```{r}
anomalies = portions[portions$warning,]
```

```{r}
midpoint = function(x){
    mid.x = weighted.mean(x$x, 1/x$rho)
    mid.y = weighted.mean(x$y, 1/x$rho)
    mid.t = weighted.mean(x$t, 1/(x$dt+1))
    estimate = c(mid.x, mid.y, mid.t)
    names(estimate) = c('x0','y0','t0')
    return(estimate)
}
anomaly.estimate = midpoint(anomalies)
anomaly.estimate
```


```{r echo=FALSE, message=FALSE, warning=FALSE}
i=5
pdf('surveillance_3D_files/estimate_weeks.pdf')
plot(baseline[[i]], main=paste('week ', as.character(i)))
  plot.ppp(epidemics[[i]], cols='red', add=T)
  tmp_portion = portions.to.plot[portions.to.plot$week_data == i,]
  n_d = dim(tmp_portion)[1]
  if (n_d > 0){
    for (j in 1:n_d[1]){
      plot.owin(disc(tmp_portion[j,4], c(tmp_portion[j,1],tmp_portion[j,2])), add=TRUE)
      points(anomaly.estimate[1], anomaly.estimate[2], pch=4, cex=5, lwd=4, col='#FF3333')
    }
  }
  dev.off()
```



# Choice of optimal mean radius
This is work in progress.
The radia of the circles are drawn from a (truncated) normal distribution with mean
`rs=0.5`. We expect that the larger the radius, the higher the count number is.
The graph below suggests that it make little sense to draw cylinders with area
smaller than $0.1$ (as it is very likely that is will turn out to be empty). Also, we expect
that the radius is related to the probability that the portion is tagged as a
warning. In oder to see this we make a joint plot `p.val` vs `area`, which again
suggests us to exclude those with areas less than $0.1$.
In the figure, the cylinders that include true outbreak events  have cross markers.

```{r}
portions$volume = portions$rho^2 * (portions$dt + 1)
color=ifelse(portions$warning, 'red', '#473B54')
par(mfrow=c(1, 2))
plot(n_obs ~ volume, data=portions, col=color, pch=16)
points(portions[portions$true_warning,]$volume, portions[portions$true_warning,]$n_obs, col='red', pch='x')

color=ifelse(portions[portions$n_obs > 0, ]$warning, 'red', '#473B54')
plot(n_obs ~ volume, data=portions[portions$n_obs > 0, ], col=color, pch=16)
points(portions[(portions$n_obs > 0)&(portions$true_warning), ]$volume, portions[(portions$n_obs > 0)&(portions$true_warning), ]$n_obs, col='red', pch='x')
```


```{r}
par(mfrow=c(1, 2))
plot(p.val ~ volume, data=portions[portions$n_obs > 0, ],col=color, pch=16)
plot(p.val ~ n_obs, data=portions[portions$n_obs > 0, ],col=color, pch=16)
points(portions[(portions$n_obs > 0)&(portions$true_warning),]$n_obs, portions[(portions$n_obs > 0)&(portions$true_warning),]$p.val, col='red', pch='x')
```

# to do:

 * write the cost function based on the area criteria of the previous section,
 * integrate the cost function into a for loop,

```{r include=FALSE}
apply.criteria<-function(portions, a, mu){
  # portions is the result of the previous run
  empty.cylinders=portions[portions$n_obs==0,]$rho
  m=mean(empty.cylinders)
  s=sd(empty.cylinders)
  rho.parameters=c(a,mu)+c(m,m+s/2)
  return(rho.parameters)
}
```





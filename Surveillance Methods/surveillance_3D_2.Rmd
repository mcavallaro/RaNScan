---
title: "Surveillance 3D"
author: "Massimo Cavallaro"
date: "22 October 2019"
output:
  pdf_document: default
  word_document: default
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library("spatstat")
```

# Baseline model definition

The basic assumption is that there are is a known baseline of (endemic) events;
as long as the recorded events are described by this baseline, no warning should be raised.
Events that are unlikely to occurr according to the baseline predictions are tagged as
potential outbreaks.

As a demonstration, we arbitarily considered a square of unit side and assumed
that the baseline $\lambda$ has a trend described by a bell (whose center
corresponds, e.g., to a region highly populated) with  trend

$$
\lambda(x,y,t) = (A/2 (\sin(t) + 1) +B)\mathrm{e}^{-B( (x-0.5)^2+(y-0.5)^2) },
$$

where $x$ and $y$ are spatial coordinates, while $t$ is an integer time index
(it seems data will be in unit of weeks, less likely days).

```{r}
library(spatstat)
temporal.trend.function<-function(t,A=7, B=0.9){
  return (A/2*(sin(t) + 1) + B)
}

spatial.trend.function<-function(x,y, C=80, B=0.5, x0=0.5, y0=0.5){
  return(B + 20*exp(-C * ( (x-x0)^2 + (y - y0)^2)))
}
n.weeks = 20

delta = 0.01
delta2 = delta ^ 2
xx = seq(0,1,delta)
yy= seq(0,1,delta)

Z = lapply(1:n.weeks, function(t)
  outer(xx, yy, function(x,y){temporal.trend(t) * spatial.trend.function(x,y)}))

win = owin(poly = data.frame(x=rev(c(0.1,0.2,0.3,0.4,0.44,0.31,0.22)),
                             y=rev(c(0.8,0.91,0.8,0.6,0.55,0.45,0.55))) )
baseline=lapply(1:n.weeks, function(t){
  rpoispp(function(x,y){ temporal.trend.function(t) * spatial.trend.function(x,y) })})

epidemics=lapply(c(0,0,0,0,1,1,1,1,0,0, 0,0,0,0,1,1,1,1,0,0), function(t){
  rpoispp(t * 50, win=win)})

Max = max(unlist(lapply(Z, max)))
my_blues = c("#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6","#4292C6","#2171B5")
#blues9
ColorRamp=colorRampPalette(c(my_blues))(1000)
```

```{r}
# include=FALSE}
png('../Manuscript/data_points_6.png', width = 3.25 *2, height = 3.25 *2, units = 'in', res=600, pointsize = 18)

par(mfrow=c(3,3), mar=c(0.9, 0.9, 0.9, 0.5))
for (i in 1:9){
  ex = max(Z[[i]])/ Max
  ColorRamp_ex = ColorRamp[1:(ex * len(ColorRamp))]

  plot(baseline[[i]], cols='#473B54', pch=16, main=paste0('t=', as.character(i)), show.window = F)
  image(xx, yy, Z[[i]], add=T, col=ColorRamp_ex)
  plot(baseline[[i]], cols='#473B54', pch=16, add=T)
  if ((i == 7) | (i == 8) | (i == 9))
    mtext(c('x' ), c(1), outer = F)
  if ((i == 1) | (i == 4) | (i == 7))
    mtext(c('y' ), c(2), outer = F)
  if (i == 3)
    mtext('A', at = 0.9, cex = 1.8, padj = 1.5)

    
  if (i %in% 5:8){
    plot(win, add=T, border='red')
  }
  plot.ppp(epidemics[[i]], cols='red', pch=16, add=T)
}
dev.off()
#palette = colorRampPalette(c('blue', 'red'))(max(cases2[,2]))


```



# plot(temporal.trend(1:10))
#``{r echo=FALSE, warning=FALSE}
# # png('surveillance_3D_files/baseline.png', width = 3.25 * 5, height = 3.25, units = 'in', res=600, pointsize = 15)
# # pdf('surveillance_3D_files/baseline_3weeks.pdf')
# x = seq(0,1,0.01)
# y = seq(0,1,0.01)
# z1 = outer(x, y, function(x,y){temporal.trend(1) * spatial.trend.function(x,y)})
# z2 = outer(x, y, function(x,y){temporal.trend(2) * spatial.trend.function(x,y)})
# z3 = outer(x, y, function(x,y){temporal.trend(3) * spatial.trend.function(x,y)})
# z4 = outer(x, y, function(x,y){temporal.trend(4) * spatial.trend.function(x,y)})
# z5 = outer(x, y, function(x,y){temporal.trend(5) * spatial.trend.function(x,y)})
# z6 = outer(x, y, function(x,y){temporal.trend(6) * spatial.trend.function(x,y)})
# z7 = outer(x, y, function(x,y){temporal.trend(7) * spatial.trend.function(x,y)})
# zlim = c(0,15)
# border=NA
# phi=20
# r=2
# axes=T
# par(mfrow=c(1,6), mar=c(1,1,1,1)) 
# persp(x,y,z1, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 1")
# persp(x,y,z2, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 2")
# persp(x,y,z3, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 3")
# persp(x,y,z4, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 4")
# persp(x,y,z5, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 5")
# persp(x,y,z6, theta=30, phi=phi, r=r, shade=0.4, axes=axes,scale=TRUE, box=TRUE,
#   nticks=5, ticktype="detailed", zlim = zlim, col="cyan", xlab="x", border=border,
#   ylab="y", zlab="", main="baseline t 6")
# # dev.off()
#`{r echo=FALSE, message=FALSE, warning=FALSE}
# pdf('surveillance_3D_files/data_9_weeks.pdf')
# (c(0,0,1,1,1,1, 0,0,0,0)


```{r include=FALSE}
observations = list()
for (i in 1:n.weeks){
  b = baseline[[i]]
  s = epidemics[[i]]
  observations[[i]] = data.frame(x=c(b$x, s$x), 
                                 y=c(b$y, s$y),
                                # color=c(rep('#473B54', length(b$x)), rep('red', length(s$x))))
                                 warning=c(rep(F, length(b$x)), rep(T, length(s$x))),
  t=rep(i, length(c(b$x, s$x))))
}
observations = do.call(rbind,  observations)
```


```{r}
writeLines(c("The number of observations is:", nrow(observations)))
```



```{r}
# x = seq(0,1,delta)
# y = seq(0,1,delta)
# z = lapply(1:10,
#            function(i){outer(x, y, function(x,y){temporal.trend(i) * spatial.trend.function(x,y)})})

is_in_circle0<-function(Data, x, y, rho){
  d = sqrt((as.numeric(Data['x'])-x)^2 + (as.numeric(Data['y'])-y)^2 )
  res<-ifelse((d<rho) & (!is.na(d)), T, F)
  return(res)
}

compute_cylinders<-function(cylinder, observations, tabulated.baseline){
  t.low = as.numeric(cylinder['t.low'])
  t.upp = as.numeric(cylinder['t.upp'])
  x0 = as.numeric(cylinder['x'])
  y0 = as.numeric(cylinder['y'])
  rho = as.numeric(cylinder['rho'])

  in_circle<-apply(tabulated.baseline, 1, is_in_circle0, x0, y0, rho)
  in_height = (tabulated.baseline$t >= t.low) & (tabulated.baseline$t <= t.upp)
  mu = sum(tabulated.baseline[in_circle & in_height,]$z) * delta2 #multiply by delta2 as this is the bin size
  
  in_of_square = sum(in_circle & in_height) * delta2
#  out_of_square = pi * rho* rho - in_of_square
  # correct by taking into account that outsise the square there is nothing. 
  mu = mu * pi * rho *rho / in_of_square
  
  in_circle<-apply(observations, 1, is_in_circle0, x0, y0, rho)
  in_height = (observations$t >= t.low) & (observations$t <= t.upp)
  n_cases_in_cylinder = sum(in_circle & in_height)
  
  ci = qpois(c(0.25,0.95) , lambda=mu)
  p.val = ppois(n_cases_in_cylinder, lambda=mu, lower.tail=FALSE)
  return (c(n_cases_in_cylinder, mu, ci, p.val))
}

init = Sys.time()

tabulated.baseline = expand.grid(xx,yy,1:n.weeks)
names(tabulated.baseline) = c('x', 'y', 't')
tabulated.baseline$z = apply(tabulated.baseline, 1,
                             function(x){
  temporal.trend(x['t']) * spatial.trend.function(x['x'],x['y'])})
# mean.baseline = mean( do.call(rbind, z) )

total.cases =  nrow(observations)
total.expected.cases = sum(tabulated.baseline$z) * delta2
correction.factor = total.cases / total.expected.cases
tabulated.baseline$z = tabulated.baseline$z * correction.factor
mean.baseline = mean(tabulated.baseline$z)

radia = sapply(1:5, function(h){sqrt(1 / mean.baseline / pi / h )} )
radia_and_heights = cbind(1:5, radia)
n.cylinders = 1000
radia_and_heights = radia_and_heights[sample(1:nrow(radia_and_heights), n.cylinders, replace=T),]
rho = radia_and_heights[,2]
random_radia = runif(n.cylinders, 0, rho)
theta = runif(n.cylinders, 0, 2* pi)

idx = sample(1:nrow(observations), n.cylinders, replace=T)
y0 = observations$y[idx] + sin(theta) * random_radia
x0 = observations$x[idx] + cos(theta) * random_radia
t = observations$t[idx] + round(runif(n.cylinders, -radia_and_heights[,1]/2, radia_and_heights[,1]/2))

t.low = t - round(radia_and_heights[,1]/2)
t.low = ifelse(t.low>0, t.low, 1)
t.upp = t.low + round(radia_and_heights[,1]/2) 
t.max = max(observations$t)
t.upp = ifelse(t.upp <= t.max, t.upp, t.max)
cylinders = data.frame(x=x0, y=y0, rho=rho, t.low=t.low, t.upp=t.upp, original.x=observations$x[idx],  original.y=observations$y[idx])

cylinders[,c('n_obs', 'mu', 'lower', 'upper', 'p.val')] = t(apply(cylinders, 1, compute_cylinders,
                                                  observations, tabulated.baseline))

cylinders$warning = apply(cylinders, 1, function(x){ifelse((x['p.val'] < 0.05) & (x['n_obs'] > 0), TRUE, FALSE)})
print(Sys.time() - init)
```


```{r}
png('../Manuscript/cylinder_plot_7.png', width = 3.25, height = 3.25, units = 'in', res=400, pointsize = 10)
#par(mfrow=c(1,1)) # mar=c(0.5, 0.5, 0.5, 0.5))
ranScanPlotCylindersCI(cylinders, confidence.level = 0.95)
dev.off()
```


```{r}

warning.score<-function(observation, cylinders){
  # check if the location
  x = as.numeric(observation['x'])
  y = as.numeric(observation['y'])
  TT = as.numeric(observation['t'])
  in_circle = apply(cylinders, 1, function(X){
    ifelse(sqrt((as.numeric(X['x']) - x)^2 + (as.numeric(X['y']) - y)^2) < as.numeric(X['rho']), 1, 0)
  })
  in_cylinder_height = apply(cylinders, 1,  function(X){
    ifelse((as.numeric(X['t.low']) <= TT) & (as.numeric(X['t.upp']) >= TT), 1, 0)
  })
  # number of cylinders that include geo-coordinate of `case`
  in_cylinder = sum(in_circle * in_cylinder_height, na.rm=T)

  # number of cylinder with `warning` flag that include location `i`
  warning = sum(cylinders$warning * in_circle * in_cylinder_height,na.rm=T)
  if (in_cylinder>0){
    re = warning / in_cylinder
  }else{
    re = 0
  } 
  return(re)
}

init = Sys.time()
observations$warning.score2 = apply(observations, 1, warning.score, cylinders)
print(Sys.time() - init)

```



```{r}
png('../Manuscript/prediction_points_7.png', width = 3.25 *2, height = 3.25 *2, units = 'in', res=600, pointsize = 18)

par(mfrow=c(3,3), mar=c(0.9,0.9,0.9,0.7))
observations[,"warning.color"] = round(observations[,"warning.score2"]  * 10) + 1 
#library(viridis)
#palette = viridis(11, begin = 0, end = 1)
palette = colorRampPalette(c("blue", "red"))(11) ## (n)
win2 = owin(poly = data.frame(x=c(0,1,1,0),y=c(0,0,1,1)) )
for (i in 1:9){
  idx = (observations$t == i)
  colors = palette[observations[idx,"warning.color"]]
  PPP = ppp(observations[idx,"x"], observations[idx,"y"], window = win2)
  plot(PPP, cex=0.1,  pch=16, main=paste0('t=', as.character(i)), show.window = F)

  ex = max(Z[[i]]) / Max
  ColorRamp_ex = ColorRamp[1:(ex * len(ColorRamp))]
  image(xx, yy, Z[[i]], add=T, col=ColorRamp_ex)
#  plot(PPP, cex=0.1,  pch=16).
  
  if ((i == 7) | (i == 8) | (i == 9))
    mtext(c('x' ), c(1), outer = F)
  if ((i == 1) | (i == 4) | (i == 7))
    mtext(c('y' ), c(2), outer = F)
  if (i == 3)
    mtext('B', at = 0.9, cex = 1.8, padj = 1.5)

  points(observations[idx,"x"], observations[idx,"y"], col=colors, pch=16, cex=1)
  if (i %in% 5:8){
    plot(win, add=T, border='red')
  }
}
dev.off()
```


```{r}
cc1 = pROC::roc(as.integer(warning) ~ warning.score, observations)
cc2 = pROC::roc(as.integer(warning) ~ warning.score2, observations)

df1 = data.frame(cc1$specificities, cc1$sensitivities, cc1$thresholds)
df2 = data.frame(cc2$specificities, cc2$sensitivities, cc2$thresholds)

idxa = which(df1$cc1.thresholds > 0.95)
idxb = which(df1$cc1.thresholds < 0.95)
idx = c(idxa[1], idxb[length(idxb)])
# print(df1)
spec_sens_cc1 = colMeans(df1[idx,])


idxa = which(df2$cc2.thresholds > 0.95)
idxb = which(df2$cc2.thresholds < 0.95)
idx = c(idxa[1], idxb[length(idxb)])
# print(df2)
spec_sens_cc2 = colMeans(df2[idx,])


```

Sensitivity: the ability of a test to correctly identify epidemic events.
Specificity: the ability of a test to correctly identify non-epidemic events.


```{r}
options(warn = - 1)
#conf_matrix<-table(ifelse(observations$warning.score2 > 0.95, T, F), observations$warning)
# sens = caret::sensitivity(conf_matrix)
# spec = caret::specificity(conf_matrix)
# cat("sensitivity=", sens, "\n")
# cat("specificity=", spec, "\n")
png('../Manuscript/ROC_.png', width = 3.25, height = 3.25, units = 'in', res=400, pointsize = 13)
par(mfrow=c(1,1), mar=c(0.5, 0.5, 0.5, 0.5))
col = '#00000033'
cc = pROC::roc(as.integer(warning) ~ warning.score2, observations)
plot(cc, col='black', identity.col='black',  grid.col='red', grid.v=spec_sens_cc1[1], grid.h = spec_sens_cc1[2])
auc = as.numeric(cc['auc'][[1]])
L = nrow(observations)
for (i in 1:50){
  cc = pROC::roc(as.integer(warning) ~ warning.score2, observations[sample(1:L, L, replace = T),])
  if(i < 11){
    plot(cc, add=T, col=col,  identity.col='black')    
  }
  auc = c(auc,as.numeric(cc['auc'][[1]]))
}
print(quantile(auc, c(0.025,0.5,0.975) ))
#     2.5%       50%     97.5% 
#0.9266877 0.9567308 0.9792924 
#0.9279978 0.9522443 0.9749876 
dev.off()
```



```
#{r echo=FALSE, message=FALSE, warning=FALSE}
library("plot3D")

plot.cylinder<-function(x,y,rho, week_i, week_f, color){
  t<-seq(0, 2*pi, length=100)
  coords<-rbind(x+rho/2*sin(t)*2, y+rho/2*cos(t)*2)
  weeks = seq(week_i, week_f)
  for (w in weeks){
    lines3D(rep(w, 100), coords[1,], coords[2,], add=TRUE, col=color)
  }
}

# engineer the list of data.frames to be used with plot3D
for (i in 1:length(temporal.trend)){
  observations[[i]]$week = i
}

all_to_plot = do.call(rbind, list(observations[[1]], observations[[2]], observations[[3]], observations[[4]], observations[[5]], observations[[6]]))
all_to_plot$color = as.character(all_to_plot$color)

total = sapply(list(observations[[1]], observations[[2]], observations[[3]], observations[[4]], observations[[5]], observations[[6]]), dim)[1,]

for (i in seq(1,6)){
  pdf(paste('3dscatterplot', i ,'.pdf', sep='_'))
  to_plot = all_to_plot[all_to_plot$week <= i, ]
  scatter3D(to_plot$week, to_plot$x, to_plot$y, zlim=c(-0.1,1.1), ylim=c(-0.1,1.1), xlim=c(0.8,6.2),
            xlab='weeks', ylab='x', zlab='y',
            # colvar=as.numeric(as.factor(to_plot$color)),
            col='#473B54',  # unique(to_plot$color),
            colkey = FALSE, pch = 16,
            phi = 25, theta = 25, alpha.col=0.1,  expand=0.5 )
  #
  text3D(x = 1:6, y = rep(0, 6), z=rep(0, 6),
         labels = c('1', '2', '3', '4', '5', '6'),
         add = TRUE, adj = 0)
  
  w = 1:length(total)
  Z = rep(1.2,length(total))
  points3D(w, Z,total/sum(total)  * 3 , add=TRUE, col='#7570B5', pch=16,  cex=2)
  lines3D(w, Z,total/sum(total)  * 3 , add=TRUE, col='#7570B5',   lty=1, lwd=4)

  if ( i == 1){
    plot.cylinder(0.5, 0.5+i/10, 0.22, 1, 1, '#473B54')
    plot.cylinder(0.7+i/10, 0.4, 0.17, 1, 1, '#473B54')
  }else if(i < 4){
    plot.cylinder(0.5, 0.5+i/10, 0.11, i-1, i, '#473B54')
    plot.cylinder(0.4+i/10, 0.3, 0.19, i-1, i, '#473B54')
  }else{
    plot.cylinder(0.45+i/100, 0.45, 0.21, i-1, i, 'red')
    plot.cylinder(0.51, 0.49+i/100, 0.15, i-1, i, '#473B54')
  }

  dev.off()
}
# 
# slice3D( 
#        # ylim = c(0, 1), bty = "g", facets = TRUE, 
#        # border = "red", col ="#7570B3", alpha=0.5,
#        # lwd = 2, phi = 20
#        )
# dev.off()
```


